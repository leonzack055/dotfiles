#!/usr/bin/env bash

# Start the ssh-agent and add keys to the agent.
# Detects if on Mac; if so detects the macOS version and provides the
# appropriate pargs to add keys to the keychain
function start_agent {
    echo "Initializing new SSH agent..."
    eval "$(ssh-agent)"

    additional_arg=""
    if [[ $OSTYPE == darwin* ]]; then
        if [[ $(sw_vers -productVersion | cut -f1 -d '.') -lt 12 ]]; then
            additional_arg="-K"
        else
            additional_arg="--apple-use-keychain"
        fi
        ssh-add "$additional_arg"
    else
        ssh-add
    fi
}

# `tre` is a shorthand for `tree` with hidden files and color enabled, ignoring
# the `.git` directory, listing directories first. The output gets piped into
# `less` with options to preserve color and line numbers, unless the output is
# small enough for one screen.
function tre() {
    tree -aC -I '.git|env|.snakemake|node_modules|bower_components' --dirsfirst "$@" | less -FRNX;
}


# Set up fzf, if it's installed
[ -f ~/.fzf.bash ] && source ~/.fzf.bash

# Select a conda env to activate
sa() {
    local name=$(conda env list | grep -v "#" | fzf)
    local env=$(echo $name | awk '{print $1}');
    eval "source activate $env";
}



function prsetup {
    if [ -z $1 ]; then
        echo "Run this function in a clone of a repo with a pull request to set up"
        echo "to push back to the contributor's fork. When creating the PR, the "
        echo "contributor must have checked the box, 'Allow edits from maintainers'."
        echo "The first argument can be determined by looking at the top of the "
        echo "PR and copying the <contributor:branch>."
        echo
        echo "Usage: prsetup <contributor:branch>"
        echo
        echo "(assumes same name of repo as current origin)"
        echo
        return 1
    fi
    current_remote=$(git remote -v | grep "^origin" | grep "(fetch)" | cut -f2 | cut -f1 -d " ")
    current_repo_name=$(basename $current_remote)

    contributor=$(echo $1 | cut -f1 -d ":")
    contributor_branch=$(echo $1 | cut -f2 -d ":")

    contributor_fork=git@github.com:$contributor/$current_repo_name.git

    echo "The following are the detected variables:"
    echo "current_remote: " $current_remote
    echo "current_repo_name: " $current_repo_name
    echo "contributor_branch: " $contributor_branch
    echo "contributor: " $contributor
    echo "contributor_fork: " $contributor_fork

    git remote add $contributor $contributor_fork
    git fetch $contributor
    git checkout -b $contributor-$contributor_branch $contributor/$contributor_branch

    echo "Now make changes, and run:"
    echo "  git push $contributor HEAD:$contributor_branch"
}

function ca() {
    # This function allows you to activate the base env only when you're ready
    # to (and don't activate it on EVERY new shell).
    #
    # You can also provide an env name or path to activate it.
    eval "$(conda shell.bash hook 2> /dev/null)"
    conda activate "$@"
}


function conda_deactivate_all() {
    # Keep deactivating until we no longer have a CONDA_PREFIX env var (which
    # might be a few times, if we had activated the base env and then another
    # env)
    eval "$(conda shell.bash hook 2> /dev/null)"
    while [ -n "$CONDA_PREFIX" ]; do
        conda deactivate;
    done
}

function hostlist() {
    # Parse ~/.ssh/config and print out a nicely-formatted table of configured
    # hosts. Useful for when you're trying to remember how to log in to an
    # infrequently-accessed host.
    paste \
        <(grep -i "^Host" ~/.ssh/config | grep -v "*" | awk '{print $2}') \
        <(grep -i "Hostname" ~/.ssh/config | grep -v "*" | awk '{print $2}') \
        | column -t \
        | sort
}

function git-clean-branches () {
    # Print local branches that have been merged into main (or master).
    #
    # Auto-detect whether to use main/master.
    local DEFAULT_BRANCH=$(git branch | grep -Ew "main|master" | sed "s/\* //")

    # Just print the names. If you're on a branch that has been merged (has
    # a "*"), don't print it
    git branch --merged $DEFAULT_BRANCH | grep -v "\*" | grep -Evw $DEFAULT_BRANCH

    echo "Use 'git-clean-branches | xargs git branch -d' to actually delete these." >&2
}

# å¿«é€Ÿè·³è½¬åˆ° Git ä»“åº“æ ¹ç›®å½•
cdgit() {
    if git rev-parse --git-dir > /dev/null 2>&1; then
        cd "$(git rev-parse --show-toplevel)"
    else
        echo "Not in a Git repository"
    fi
}

# æ˜¾ç¤ºè¯¦ç»†çš„ Git çŠ¶æ€æ‘˜è¦
git_summary() {
    if git rev-parse --git-dir > /dev/null 2>&1; then
        echo "=== Git Repository Summary ==="
        echo "Branch: $(git symbolic-ref --short HEAD 2>/dev/null || echo 'Detached HEAD')"
        echo "Remote: $(git remote get-url origin 2>/dev/null || echo 'No remote')"
        echo "Status: $(git status --porcelain 2>/dev/null | wc -l) files changed"
        if [[ -n $(git status --porcelain 2>/dev/null) ]]; then
            echo
            git status --short
        fi
    else
        echo "Not in a Git repository"
    fi
}

# ========== ä»£ç†é…ç½®å¸¸é‡ï¼ˆæŒ‰éœ€ä¿®æ”¹ï¼‰ ==========
#PROXY_ADDR="http://127.0.0.1:8119"  # ä½ çš„ä»£ç†åœ°å€+ç«¯å£
#NO_PROXY_LIST="localhost,127.0.0.1,10.*,192.168.*,10.4.0.178,hub.byd.com"  # å†…ç½‘ç›´è¿åˆ—è¡¨
PROXY_ADDR="http://127.0.0.1:8119"
NO_PROXY_LIST="localhost,127.0.0.1,10.*,192.168.*"

# ========== 1. åŠ è½½ä»£ç†ï¼ˆå¤–ç½‘èµ°ä»£ç†ï¼‰ ==========
function set-proxy() {
    # 1. è®¾ç½®ç³»ç»Ÿçº§ä»£ç†ï¼ˆå½±å“ curl/wget/git ç­‰æ‰€æœ‰å·¥å…·ï¼‰
    export http_proxy=$PROXY_ADDR
    export https_proxy=$PROXY_ADDR
    export all_proxy=$PROXY_ADDR
    export HTTP_PROXY=$PROXY_ADDR
    export HTTPS_PROXY=$PROXY_ADDR
    export ALL_PROXY=$PROXY_ADDR
    export NO_PROXY=$NO_PROXY_LIST
    export no_proxy=$NO_PROXY_LIST

    # 2. è®¾ç½® Git å…¨å±€ä»£ç†ï¼ˆå…œåº•ï¼Œç¡®ä¿ Git è¯†åˆ«ï¼‰
    git config --global http.proxy $PROXY_ADDR
    git config --global https.proxy $PROXY_ADDR
    git config --global http.noProxy $NO_PROXY_LIST

    # æç¤ºç”Ÿæ•ˆ
    echo -e "\033[32mâœ… ä»£ç†å·²åŠ è½½ï¼š$PROXY_ADDR\033[0m"
    echo -e "\033[36mğŸ” ç»•è¿‡ä»£ç†ï¼š$NO_PROXY_LIST\033[0m"
}

# ========== 2. å–æ¶ˆä»£ç†ï¼ˆå†…ç½‘ç›´è¿ï¼‰ ==========
function unset-proxy() {
    # 1. æ¸…ç©ºç³»ç»Ÿçº§ä»£ç†
    unset http_proxy https_proxy all_proxy
    unset HTTP_PROXY HTTPS_PROXY ALL_PROXY
    unset NO_PROXY no_proxy

    # 2. æ¸…ç©º Git å…¨å±€ä»£ç†
    git config --global --unset http.proxy
    git config --global --unset https.proxy
    git config --global --unset http.noProxy

    # æç¤ºç”Ÿæ•ˆ
    echo -e "\033[31mâŒ ä»£ç†å·²å–æ¶ˆï¼Œå½“å‰ä¸ºç›´è¿æ¨¡å¼\033[0m"
}

# ========== 3. æŸ¥çœ‹å½“å‰ä»£ç†çŠ¶æ€ï¼ˆå¯é€‰ï¼Œæ–¹ä¾¿æ’æŸ¥ï¼‰ ==========
function check-proxy() {
    echo -e "\033[33m===== ç³»ç»Ÿä»£ç†çŠ¶æ€ =====\033[0m"
    echo "http_proxy: ${http_proxy:-æœªè®¾ç½®}"
    echo "https_proxy: ${https_proxy:-æœªè®¾ç½®}"
    echo "no_proxy: ${no_proxy:-æœªè®¾ç½®}"
    echo -e "\033[33m===== Git ä»£ç†çŠ¶æ€ =====\033[0m"
    git config --global --get http.proxy || echo "Git http.proxy: æœªè®¾ç½®"
    git config --global --get http.noProxy || echo "Git http.noProxy: æœªè®¾ç½®"
}

#============ 4. yazi å¯åŠ¨æ–¹å¼ =============================
function y() {
	local tmp="$(mktemp -t "yazi-cwd.XXXXXX")" cwd
	yazi "$@" --cwd-file="$tmp"
	IFS= read -r -d '' cwd < "$tmp"
	[ -n "$cwd" ] && [ "$cwd" != "$PWD" ] && builtin cd -- "$cwd"
	rm -f -- "$tmp"
}